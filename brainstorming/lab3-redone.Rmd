---
title: "Re-doing Lab 3"
author: ":)"
date: "`r format(Sys.time(), '%d %B, %Y %H:%M:%OS')`"
output:
  pdf_document: default
---

```{r setup, include=FALSE}
# DO NOT ALTER CODE IN THIS CHUNK
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.width=8, fig.height=6, fig.align = 'center')
```


* * *

Complete the following exercises before the submission deadline. In addition to the points detailed below, 5 points are assigned to the quality of the annotation, as well as to the 'cleanliness' of the code and resulting pdf document.

## Exercise 1 -- 1 point

We will again be working with the BC Parks dataset, which contains information on the locations of Provincial Parks in British Columbia. The parks belong to 5 different regions. There is also information on elevation (in m) and percent forest cover contained within the dataset.

* Import the BC park locations dataset and convert the data to a `ppp` object (for today you can exclude information on regions).  -- 1 point(s)

Note: You will need to load the `maptools` package and make use of the `as.owin()` function.

```{r}
# 1
#quiet function
quiet <- function(x) { 
  sink(tempfile()) 
  on.exit(sink()) 
  invisible(force(x)) 
}

#importing dataset
lc = read.csv("../datasets/processed/lc.csv")

#importing window
suppressMessages(library(spatstat))
suppressMessages(library(sf))
suppressMessages(library(maptools))
load("../datasets/raw/BC_Covariates.Rda")
bc_window_sf = st_as_sf(DATA$Window)
bc_window_owin = as.owin(bc_window_sf)

#converting to a ppp
lc_ppp = ppp(x = lc$decimalLongitude, 
              y = lc$decimalLatitude, 
              window = bc_window_owin, 
              )

plot(lc_ppp, pch = 16, cols = "#046C9A", cex = 0.6)
```

## Exercise 2 -- 4 points

* Estimate and plot $\rho$ for the locations of parks as a function of both elevation and forest cover (be sure that the x-axis for elevation does not go below 0).  -- 2 point(s)
* Check for collinearity between elevation and forest cover (you will need to consider NA values).  -- 1 point(s)
* Based on these initial analyses, write down the expected form of the model. Provide justification for this starting point.  -- 1 point(s)

Note: Estimating rho can be slow ($\sim$ 1-2 min). Be sure to leave enough time for the document to knit.

```{r, cache=TRUE}
# 1
elev = DATA$Elevation
rho_elev = rhohat(lc_ppp, elev)
forest = DATA$Forest
rho_forest = rhohat(lc_ppp, forest)
par(mfrow = c(1,2))
plot(rho_elev,
     main = "",
     xlab = "Elevation (m)", 
     xlim=c(0, 3600))
plot(rho_forest,
     main = "",
     xlab = "Forest Cover (%)")
par(mfrow = c(1,1))
```

HFI is based on: population density, land transformation, human access, and power infrastructure. 

```{r, cache=TRUE}
# 1
hfi = DATA$HFI
rho_hfi = rhohat(lc_ppp, hfi)
distw = DATA$Dist_Water
rho_distw = rhohat(lc_ppp, distw)
par(mfrow = c(1,2))
plot(rho_hfi,
     main = "",
     xlab = "Human Footprint Index")
plot(rho_distw,
     main = "",
     xlab = "Distance to Water (m)")
par(mfrow = c(1,1))

#correlation
cor.im(elev, forest, hfi, distw,  use = 'complete.obs')
```

<!--
\[\lambda_{parks}(u) = e^{\beta_0 + \beta_1 \textrm{elevation(u)} + \beta_2 \textrm{elevation(u)}^2 + \beta_3 \textrm{forest(u)} + \beta_4 \textrm{forest(u)}^2}\]
--> 



## Exercise 3 -- 4 points

* Fit the model you have defined in exercise 2 and inspect the model output. -- 1 point(s)
* Fit a null, intercept only model.  -- 1 point(s)
* Use AIC and a likelihood ratio test to determine if the model you defined is a better fit than the intercept only model.  -- 1 point(s)
* Write down the equation for the selected model. -- 0.5 point(s)
* Use this equation to estimate the intensity of parks at 500m elevation and 50% forest cover.

```{r, cache=TRUE}
# 0
#mean centering and scaling the elevation and distance to water variables 
mu <- mean(DATA$Elevation)
stdev <- sd(DATA$Elevation)
Elevation_scaled <- eval.im((elev - mu)/stdev, DATA)
mu <- mean(DATA$Dist_Water)
stdev <- sd(DATA$Dist_Water)
Dist_Water_scaled <- eval.im((distw - mu)/stdev, DATA)

# 1
fit1 = ppm(lc_ppp ~ Elevation_scaled + I(Elevation_scaled^2) + forest + I(forest^2) + hfi + I(hfi^2) + Dist_Water_scaled + I(Dist_Water_scaled^2))
fit1

# 1.5
fit2 = ppm(lc_ppp ~ Elevation_scaled + I(Elevation_scaled^2) + hfi + I(hfi^2))
fit2

# 2 
fit_intercept = ppm(lc_ppp ~ 1)
fit_intercept

# 3
AIC(fit1); AIC(fit2); AIC(fit_intercept)
AIC(fit2) - AIC(fit1) #delta AIC
anova(fit2, fit1, test = "LRT") #LRT
#the positive delta AIC and the small p-value from the LRT both point 
#to the more complex model being more parsimonious (better fit and 
#worth it)

#plotting ppm prediction
plot(fit2,
     se = FALSE,
     superimpose = FALSE)
plot(lc_ppp,
     pch = 16,
     cex = 0.6,
     cols = "white",
     add = TRUE)
plot(lc_ppp,
     pch = 16,
     cex = 0.5,
     cols = "black",
     add = TRUE)
```

```{r, cache=TRUE, warning=FALSE}
#lurking variable plot
lurking(fit2, elev, type = "raw", cumulative = F, envelope = T, xlab = "Elevation (m)" )
```


```{r, cache=TRUE, warning=FALSE}
###############################
#### GAM
###############################

library(splines)
fit_smooth = suppressWarnings(ppm(lc_ppp ~ bs(Elevation_scaled,7) + bs(Dist_Water_scaled, 8) + 
                   bs(forest, 8) + bs(hfi, 8), use.gam = TRUE))
fit_smooth

#checking AIC
AIC(fit2); AIC(fit_smooth)
AIC(fit2) - AIC(fit_smooth)
anova(fit2, fit_smooth, test = "LRT")
#Plot the model predictions
plot(fit_smooth,
     se = FALSE,
     superimpose = FALSE,
     main = "Lynx GAM")
plot(lc_ppp,
     pch = 16,
     cex = 0.6,
     cols = "white",
     add = TRUE)
plot(lc_ppp,
     pch = 16,
     cex = 0.5,
     cols = "black",
     add = TRUE)
```


<!--
\[\lambda_{parks}(u) = e^{-20.72-0.00393*\textrm{elevation(u)}+0.00000139*\textrm{elevation(u)}^2+0.048*\textrm{forest(u)}-0.000439*\textrm{forest(u)}^2}\]
-->

## Exercise 4 -- 4 points

* Visualise the fitted model. Note: log scale the estimated intensity when plotting, ignore the standard error. You can use the `n` argument to adjust the resolution  -- 1 point(s)
* Plot the effects of the individual coefficients. Note: use the median value(s) of the other coefficients.  -- 2 point(s)
* Visually, do you think the model predictions are a good match to the data?  -- 1 point(s)

```{r}
#See above
```


## Exercise 5 -- 1 point

* Test whether the observed data deviate significantly from the model predictions. -- 1 point(s)

```{r}
# 1
library(splines)
quadrat.test(fit2, nx = 2, ny = 4)
quadrat.test(fit_smooth, nx = 2, ny = 4) #doesnt run
#The small p value tells us that there’s a significant deviation 
#from our model’s predictions.
```


## Exercise 5 -- 2 points

* Calculate and plot the model residuals.  -- 1 point(s)
* Based on the residuals, do you think the model performing well?  -- 1 point(s)

```{r, cache=TRUE, warning=FALSE}
# 1
#plot(residuals(fit2), cols = "transparent")
#plot(residuals(fit_smooth), cols = "transparent")
#residuals function doesnt run
#using diagnose.ppm instead:
diagnose.ppm(fit2)
diagnose.ppm(fit_smooth)
```



## Exercise 6 -- 3 points

* Calculate the partial residuals as a function of both elevation and forest cover.  -- 1 point(s)
* Do you think that the terms are accurately capturing trends in the data?  -- 1 point(s)
* Do you have enough information to further refine the model and improve it's accuracy?  -- 1 point(s)

```{r, cache=TRUE, warning=FALSE}
#PPM
par_res_elev_ppm = parres(fit2, "Elevation_scaled")
par_res_hfi_ppm = parres(fit2, 'hfi')
par(mfrow = c(1,2))
plot(par_res_elev_ppm,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Elevation Scaled (m)")
plot(par_res_hfi_ppm,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "HFI")
par(mfrow = c(1,1))

#GAM
library(splines)
par_res_elev = parres(fit_smooth, "Elevation_scaled")
par_res_distw = parres(fit_smooth, "Dist_Water_scaled")
par_res_hfi = parres(fit_smooth, 'hfi')
par_res_forest = parres(fit_smooth, 'forest')

#Side by side plotting
par(mfrow = c(1,2))
plot(par_res_elev,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Elevation Scaled (m)")
plot(par_res_distw,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Distance to Water Scaled (m)")
plot(par_res_hfi,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "HFI")
plot(par_res_forest,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Forest Coverage (%)")
par(mfrow = c(1,1)) 
```


## Model Validation

### Intensity of a fitted point process model as a function of one of its covariates

```{r, cache=TRUE}
## For PPM fit 
#Elevational effect on lambda at mean hfi
elev_effect = effectfun(fit2, "Elevation_scaled", hfi = mean(hfi), se.fit = T)

#HFI effect on lambda at mean elevation
hfi_effect = effectfun(fit2, "hfi", Elevation_scaled = mean(Elevation_scaled), se.fit = T)

#Side by side plotting
par(mfrow = c(1,2))
#Plot the elevation effect 
plot(elev_effect,
     legend = FALSE,
     main = "Elevational effect at mean HFI")

#Plot the slope effect 
plot(hfi_effect,
     legend = FALSE,
     main = "Effect of HFI at mean elevation")
par(mfrow = c(1,1))
```


### Relative Intensity

```{r, cache=TRUE, eval=FALSE}
#Calculate the relative intensity as a function of elevation
rh_elev = rhohat(na.omit(fit2), na.omit(Elevation_scaled))

#Calculate the relative intensity as a function of hfi
rh_hfi = rhohat(na.omit(fit2), na.omit(hfi))

#Side by side plotting
par(mfrow = c(1,2))
plot(rh_elev,
     legend = FALSE,
     main = "",
     xlab = "Elevation scaled (m)")
plot(rh_hfi,
     legend = FALSE,
     main = "",
     xlab = "HFI")
par(mfrow = c(1,1))
```

 
